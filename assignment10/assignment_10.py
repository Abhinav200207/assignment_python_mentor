# -*- coding: utf-8 -*-
"""Assignment 10

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bSzq9LvV7BOuTNKKsW3CZtRsyKJiUtKR
"""


# 1
import numpy as np

def extract_subpart(arr, center, shape, fill=0):
    h, w = shape
    a_h, a_w = arr.shape
    sub_arr = np.full(shape, fill)

    for i in range(h):
        for j in range(w):
            y = center[0] + i - h // 2
            x = center[1] + j - w // 2
            if 0 <= y < a_h and 0 <= x < a_w:
                sub_arr[i, j] = arr[y, x]
    return sub_arr

z = np.arange(1, 26).reshape(5, 5)
center = (2, 2)
print(extract_subpart(z, center, (3, 3), fill=-1))

# 2
print("="*60)
def sliding_window(z, k):
    res = []
    for i in range(len(z) - k + 1):
        res.append(z[i:i+k])
    return res

z = [1,2,3,4,5,6,7,8,9,10,11,12,13,14]
print(sliding_window(z, 4))

# 3
print("="*60)
def matrix_rank(m):
    u, s, vh = np.linalg.svd(m)
    return sum(s > 1e-10)

m = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(matrix_rank(m))

# 4
print("="*60)
def most_frequent(arr):
    freq = {}
    for x in arr:
        if x in freq:
            freq[x] += 1
        else:
            freq[x] = 1
    return max(freq, key=freq.get)

arr = [1, 2, 2, 3, 3, 3, 4]
print(most_frequent(arr))

# 5
print("="*60)
def contiguous_blocks(arr, block_size):
    blocks = []
    for i in range(arr.shape[0] - block_size + 1):
        for j in range(arr.shape[1] - block_size + 1):
            blocks.append(arr[i:i+block_size, j:j+block_size])
    return blocks

arr = np.array([[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                [2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
                [3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
                [4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
                [5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
                [6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
                [7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
                [8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
                [9, 10, 11, 12, 13, 14, 15, 16, 17, 18],
                [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]])

blocks = contiguous_blocks(arr, 3)
for b in blocks:
    print(b)

# 10
print("="*60)
def n_largest(arr, n):
    arr_sorted = sorted(arr, reverse=True)
    return arr_sorted[:n]

z = [19,45,3,3,76,4,5,23,65,98,55,13]
print(n_largest(z, 5))

# 14
print("="*60)
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 3, 5], [0, 2, 4], [4, 6, 8], [1, 2, 4], [2, 3, 5]])
b = np.array([[1, 2], [4, 5]])

def check_rows(a, b):
    res = []
    for row_a in a:
        for row_b in b:
            if all(item in row_a for item in row_b):
                res.append(row_a)
    return res

result = check_rows(a, b)
print(result)

# 15
print("="*60)
z = np.array(
  [[0, 2, 1],
   [3, 1, 1],
   [0, 1, 4],
   [2, 3, 3],
   [1, 0, 4],
   [3, 0, 0],
   [3, 1, 4],
   [2, 1, 4],
   [0, 1, 4],
   [0, 3, 3]])

def unequal_rows(arr):
    res = []
    for row in arr:
        if len(set(row)) == len(row):
            res.append(row)
    return np.array(res)

print(unequal_rows(z))

# 16
print("="*60)
v = np.array([1, 2, 3, 4])

def to_binary_matrix(vec):
    res = []
    for val in vec:
        bin = format(val, '08b')
        res.append([int(bit) for bit in bin])
    return np.array(res)

print(to_binary_matrix(v))

# 17
print("="*60)
arr = np.array([[1, 0, 0],
                [0, 1, 0],
                [1, 0, 1],
                [0, 1, 1],
                [1, 1, 0]])

def unique_rows(arr):
    unique = np.unique(arr, axis=0)
    return unique

print(unique_rows(arr))

# 18
print("="*60)
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

inner = np.einsum('i,i', a, b)
outer = np.einsum('i,j', a, b)
summed = np.einsum('i', a)
mult = np.einsum('i,i->i', a, b)

print(inner, outer, summed, mult)

# 20
print("="*60)
n = 10
x = np.array([[3, 3, 3, 1, 0],
              [2, 2, 2, 2, 2],
              [5, 3, 1, 0, 1],
              [3, 4, 2, 1, 0],
              [1, 1, 1, 1, 1],
              [2, 2, 2, 2, 2],
              [0, 5, 3, 2, 1],
              [3, 3, 3, 3, 3],
              [1, 1, 1, 1, 1],
              [2, 2, 2, 2, 2]])

def multinomial_rows(x, n):
    res = []
    for row in x:
        if np.all(row == np.round(row)) and np.sum(row) == n:
            res.append(row)
    return np.array(res)

print(multinomial_rows(x, n))
